Об изучении Coq и математике
Когда мы учимся программировать, для нас важно, чтобы программа "заработала": чтобы в определённой ситуации программа продемонстрировала ожидаемое поведение. При этом мы думаем примерно так:
- Сейчас мы находимся в контексте A
- Мы хотим получить другое состояние программы B
- Как из A построить дорогу в B, скомбинировав конструкции языка?

В результате мы строим инфраструктуру, чтобы удобно добраться до цели.

И здесь кроется источник подавляющего большинства ошибок. Программа написана _действительно_ правильно только тогда, когда по выстроенной сети дорог нельзя забрести туда, куда вы не хотите попасть. Мы же, размышляя о правильности куска кода, как правило довольствуемся достаточно поверхностным анализом возможных значений данных и, как следствие, возможных трасс выполнения.

Большинство языков, используемых в индустрии и для обучения, дают очень много свободы ровно в тех местах, где этого делать категорически не нужно. Например, конструкция switch никак не контролирует, для всех ли значений аргумента есть ветки.

Первым шагом в сторону более правильного подхода является знакомство с функциональными языками с развитой системой типов, например, ocaml или haskell. Их синтаксис и семантика устроены так, что мы постоянно вынуждены думать о всех возможных ветках выполнения программы. Речь идёт о, например, использовании exhaustive pattern matching, стирании границы между expression и statement, обязательности ветки else. Теперь, когда я пишу на том же С, я думаю совершенно по-другому, нежели до знакомства с ФП, ибо правильный рефлекс переносится и на этот, весьма нестрогий язык.

Поработав несколько лет с Coq я заметил, что процесс доказательств развивает такой стиль мышления ещё сильнее. Написать хоть сколько-нибудь нетривиальную работающую программу на Coq и доказать ее корректность — задача, великолепно развивающая умение разбирать случаи.

Разумеется, когда люди просто занимаются математикой, происходит то же самое. Особенность и полезность написания доказательств в Coq именно в факте их постоянной проверки и битья по рукам в случае неучтённых возможных веток выполнения и некорректных логических переходов. Кроме того, такие доказательства гораздо подробнее: каждый логический переход должен быть указан явно. Это приучает к дисциплине и тщательности.

